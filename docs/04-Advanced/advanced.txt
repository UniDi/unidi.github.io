There are also settings for the signals system which are documented [here](#settings).

## Signals

See [here](Documentation/Signals.md).

## Memory Pools

See [here](Documentation/MemoryPools.md).

## Update / Initialization Order

In many cases, especially for small projects, the order that classes update or initialize in does not matter.  However, in larger projects update or initialization order can become an issue.  This can especially be an issue in Unity, since it is often difficult to predict in what order the `Start()`, `Awake()`, or `Update()` methods will be called in.  Unfortunately, Unity does not have an easy way to control this (besides in `Edit -> Project Settings -> Script Execution Order`, though that can be awkward to use)

In UniDi, by default, ITickables and IInitializables are called in the order that they are added, however for cases where the update or initialization order does matter, there is another way that is sometimes better:  By specifying their priorities explicitly in the installer.  For example, in the sample project you can find this code in the scene installer:

```csharp
public class AsteroidsInstaller : MonoInstaller
{
    ...

    void InitExecutionOrder()
    {
        // In many cases you don't need to worry about execution order,
        // however sometimes it can be important
        // If for example we wanted to ensure that AsteroidManager.Initialize
        // always gets called before GameController.Initialize (and similarly for Tick)
        // Then we could do the following:
        Container.BindExecutionOrder<AsteroidManager>(-10);
        Container.BindExecutionOrder<GameController>(-20);

        // Note that they will be disposed of in the reverse order given here
    }

    ...

    public override void InstallBindings()
    {
        ...
        InitExecutionOrder();
        ...
    }

}
```

This way, you won't hit a wall at the end of the project due to some unforeseen order-dependency.

Note here that the value given to `BindExecutionOrder` will apply to `ITickable` / `IInitializable` and `IDisposable` (with the order reversed for `IDisposable`'s).

You can also assign priorities for each specific interface separately like this:

```csharp
Container.BindInitializableExecutionOrder<Foo>(-10);
Container.BindInitializableExecutionOrder<Bar>(-20);

Container.BindTickableExecutionOrder<Foo>(10);
Container.BindTickableExecutionOrder<Bar>(-80);
```

Any ITickables, IInitializables, or IDisposables that are not assigned a priority are automatically given the priority of zero.  This allows you to have classes with explicit priorities executed either before or after the unspecified classes.  For example, the above code would result in `Foo.Initialize` being called before `Bar.Initialize`.

## UniDi Order Of Operations

What follows below is a more detailed view of what happens when running a scene that uses UniDi.  This can be useful to know to fully understand exactly how UniDi works.

* Unity Awake() phase begins
    * SceneContext.Awake() method is called.  This should always be the first thing executed in your scene.  It should work this way by default (see [here](#bad-execution-order) if you are noticing otherwise).
    * Project Context is initialized. Note that this only happens once per play session.  If a previous scene already initialized the ProjectContext, then this step is skipped
        * All injectable MonoBehaviour's on the ProjectContext prefab are passed to the container via [DiContainer.QueueForInject](#dicontainer-methods-queueforinject)
        * ProjectContext iterates through all the Installers that have been added to its prefab via the Unity Inspector, runs injects on them, then calls InstallBindings() on each.  Each Installer calls some number of Bind methods on the DiContainer.
        * ProjectContext then constructs all the non-lazy root objects, which includes any classes that derive from ITickable / IInitializable or IDisposable, as well as those classes that are added with a `NonLazy()` binding.
        * All instances that were added via [DiContainer.QueueForInject](#dicontainer-methods-queueforinject) are injected
    * Scene Context is initialized.
        * All injectable MonoBehaviour's in the entire scene are passed to the SceneContext container via [DiContainer.QueueForInject](#dicontainer-methods-queueforinject)
        * SceneContext iterates through all the Installers that have been added to it via the Unity Inspector, runs injects on them, then calls InstallBindings() on each.  Each Installer calls some number of Bind<> methods on the DiContainer.
        * SceneContext then constructs all the non-lazy root objects, which includes any classes that derive from ITickable / IInitializable or IDisposable, as well as those classes that are added with a `NonLazy()` binding.
        * All instances that were added via [DiContainer.QueueForInject](#dicontainer-methods-queueforinject) are injected
    * If any required dependencies cannot be resolved, a UniDiResolveException is thrown
    * All other MonoBehaviour's in the scene have their Awake() method called
* Unity Start() phase begins
    * ProjectKernel.Start() method is called.  This will trigger the Initialize() method on all `IInitializable` objects in the order specified in the ProjectContext installers.
    * SceneKernel.Start() method is called.  This will trigger the Initialize() method on all `IInitializable` objects in the order specified in the SceneContext installers.
    * All other MonoBehaviour's in your scene have their Start() method called
* Unity Update() phase begins
    * ProjectKernel.Update() is called, which results in Tick() being called for all `ITickable` objects (in the order specified in the ProjectContext installers)
    * SceneKernel.Update() is called, which results in Tick() being called for all `ITickable` objects (in the order specified in the SceneContext installers)
    * All other MonoBehaviour's in your scene have their Update() method called
* These same steps repeated for LateUpdate and ILateTickable
* At the same time, These same steps are repeated for FixedUpdate according to the physics timestep
* Unity scene is unloaded
    * Dispose() is called on all objects mapped to `IDisposable` within all the GameObjectContext's (see [here](#implementing-idisposable) for details)
    * Dispose() is called on all objects mapped to `IDisposable` within the SceneContext installers (see [here](#implementing-idisposable) for details)
* App is exitted
    * Dispose() is called on all objects mapped to `IDisposable` within the ProjectContext installers (see [here](#implementing-idisposable) for details)

## Injecting data across scenes

In some cases it's useful to pass arguments from one scene to another.  The way Unity allows us to do this by default is fairly awkward.  Your options are to create a persistent GameObject and call DontDestroyOnLoad() to keep it alive when changing scenes, or use global static classes to temporarily store the data.

Let's pretend you want to specify a 'level' string to the next scene.  You have the following class that requires the input:

```csharp
public class LevelHandler : IInitializable
{
    readonly string _startLevel;

    public LevelHandler(
        [InjectOptional]
        string startLevel)
    {
        if (startLevel == null)
        {
            _startLevel = "default_level";
        }
        else
        {
            _startLevel = startLevel;
        }
    }

    public void Initialize()
    {
        ...
        [Load level]
        ...
    }
}
```

You can load the scene containing `LevelHandler` and specify a particular level by using the following syntax:

```csharp

public class Foo
{
    readonly UniDiSceneLoader _sceneLoader;

    public Foo(UniDiSceneLoader sceneLoader)
    {
        _sceneLoader = sceneLoader;
    }

    public void AdvanceScene()
    {
        _sceneLoader.LoadScene("NameOfSceneToLoad", LoadSceneMode.Single, (container) =>
            {
                container.BindInstance("custom_level").WhenInjectedInto<LevelHandler>();
            });
    }
}
```

The bindings that we add here inside the lambda will be added to the container as if they were inside an installer in the new scene.

Note that you can still run the scene directly, in which case it will default to using "default_level".  This is possible because we are using the `InjectOptional` flag.

An alternative and arguably cleaner way to do this would be to customize the installer itself rather than the `LevelHandler` class.  In this case we can write our `LevelHandler` class like this (without the `[InjectOptional]` flag).

```csharp
public class LevelHandler : IInitializable
{
    readonly string _startLevel;

    public LevelHandler(string startLevel)
    {
        _startLevel = startLevel;
    }

    public void Initialize()
    {
        ...
        [Load level]
        ...
    }
}
```

Then, in the installer for our scene we can include the following:

```csharp
public class GameInstaller : Installer
{
    [InjectOptional]
    public string LevelName = "default_level";

    ...

    public override void InstallBindings()
    {
        ...
        Container.BindInstance(LevelName).WhenInjectedInto<LevelHandler>();
        ...
    }
}
```

Then, instead of injecting directly into the `LevelHandler` we can inject into the installer instead.

```csharp

public class Foo
{
    readonly UniDiSceneLoader _sceneLoader;

    public Foo(UniDiSceneLoader sceneLoader)
    {
        _sceneLoader = sceneLoader;
    }

    public void AdvanceScene()
    {
        _sceneLoader.LoadScene("NameOfSceneToLoad", (container) =>
            {
                container.BindInstance("custom_level").WhenInjectedInto<GameInstaller>();
            });
    }
}
```

The `UniDiSceneLoader` class also allows for more complex scenarios, such as loading a scene as a "child" of the current scene, which would cause the new scene to inherit all the dependencies in the current scene.  However, it is often better to use [Scene Contract Names](#scene-parenting) for this instead.

## Scene Parenting Using Contract Names

Putting bindings inside ProjectContext is a fast and easy way to add common long-lasting dependencies that are shared across scenes.  However, in many cases you have bindings that you only want to be shared between specific scenes, so using ProjectContext doesn't work since in that case, the bindings we add there are global to every single scene in our entire project.

As an example, let's pretend that we are working on a spaceship game, and we want to create one scene to serve as the environment (involving planets, asteroids, stars, etc.) and we want to create another scene to represent the ship that the player is in.  We also want all the classes in the ship scene to be able to reference bindings declared in the environment scene.  Also, we want to be able to define multiple different versions of both the ship scene and the environment scene.  To achieve all this, we will use a UniDi feature called 'Scene Contract Names'.

We will start by using Unity's support for [multi-scene editting](https://docs.unity3d.com/Manual/MultiSceneEditing.html), and dragging both our environment scene and our ship scene into the Scene Hierarchy tab.  Then we will select the SceneContext in the environment scene and add a 'Contract Name'.  Let's call it 'Environment'.  Then all we have to do now is select the SceneContext inside the ship scene and set its 'Parent Contract Name' to the same value ('Environment').  Now if we press play, all the classes in the ship scene can access the declared bindings in the environment scene.

The reason we use a name field here instead of explicitly using the scene name is to support swapping out the various environment scenes for different implementations.  In this example, we might define several different environments, all using the same Contract Name 'Environment', so that we can easily mix and match them with different ship scenes just by dragging the scenes we want into the scene hierarchy then hitting play.

It is called 'Contract Name' because all the environment scenes will be expected to follow a certain 'contract' by the ship scenes.  For example, the ship scenes might require that regardless of which environment scene was loaded, there is a binding for 'AsteroidManager' containing the list of asteroids that the ship must avoid.

Note that you do not need to load the environment scene and the ship scene at the same time for this to work.  For example, you might want to have a menu embedded inside the environment to allow the user to choose their ship before starting.  So you could create a menu scene and load that after the environment scene.   Then once the user chooses their ship, you could load the associated ship scene by calling the unity method `SceneManager.LoadScene` (making sure to use `LoadSceneMode.Additive`).

Also note that the Validate command can be used to quickly verify the different multi-scene setups.  If you find that scenes are unloaded when you do this see [here](https://github.com/modesttree/UniDi/issues/168).

Also, I should mention that Unity currently doesn't have a built-in way to save and restore multi-scene setups.  We use a simple editor script for this that you can find [here](https://gist.github.com/svermeulen/8927b29b2bfab4e84c950b6788b0c677) if interested.

## Default Scene Parents

One drawback to using scene parent contract names instead of ProjectContext to add bindings shared across scenes, is that you always have to remember to configure the scene hierarchy inside Unity to contain the correct scenes before running it.  You can't simply open different scenes and hit Play like you can with ProjectContext.  So to address this, UniDi allows specifying a default value for the different contract names in cases where an existing value is not already loaded.

To take our example from [above](#scene-parenting), we'd like to be able to open Ship scene and immediately hit play without needing to place an environment scene above that first.  To do this, right click in your Projects tab and select `Create -> UniDi -> Default Scene Contract Config`.  Note that you will have to do this by right clicking on a folder named Resources for this to work.

After adding this you can click on the `UniDiDefaultSceneContractConfig` object and add any number of defaults by typing in contract names and then dragging in scene files from the Project tab into the Scene property.  After doing this, you should be able to directly run the Ship scene and the default environment scene will automatically be loaded above that.

Note that the default scene for a given contract will also be used when using [scene decorators](#scenes-decorator)

Note that this is an editor only feature.  The default contract names will not be used in builds.  In those cases you will have to explicitly load the correct parent scenes yourself in code.

## Scene Decorators

Scene Decorators offer another approach to using multiple scenes together with UniDi in addition to [scene parenting](#scene-parenting) described above.  The difference is that with scene decorators, the multiple scenes in question will all share the same Container and therefore all scenes can access bindings in all other scenes (unlike with scene parenting where only the child can access the parent bindings and not vice versa).

Another way to think about scene decorators is that it is a more advanced way doing the process described [for injecting data across scenes](#injecting-data-across-scenes).  That is, they can be used to add behaviour to another scene without actually changing the installers in that scene.

Usually, when you want to customize different behaviour for a given scene depending on some conditions, you would use boolean or enum properties on MonoInstallers, which would then be used to add different bindings depending on the values set.  However, the scene decorator approach can be cleaner sometimes because it doesn't involve changing the main scene.

For example, let's say we want to add some special keyboard shortcuts to your main production scene for testing purposes.  In order to do this using decorators, you would do the following:

* Open the main production scene
* Right click on the far right menu beside the scene name within the scene hierarchy and select Add New Scene
* Drag the scene so it's above the main scene
* Right Click inside the new scene and select `UniDi -> Decorator Context`
* Select the Decorator Context and set the 'Decorated Contract Name' field to 'Main'
* Select the SceneContext in the main scene and add a contract name with the same value ('Main')
* Create a new C# script with the following contents, then add this MonoBehaviour to your decorator scene as a gameObject, then drag it to the `Installers` property of `SceneDecoratorContext`

```csharp
public class ExampleDecoratorInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Bind<ITickable>().To<TestHotKeysAdder>().AsSingle();
    }
}

public class TestHotKeysAdder : ITickable
{
    public void Tick()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Hotkey triggered!");
        }
    }
}
```

Note the following:

- If you run your scene it should now behave exactly like the main scene except with the added functionality in your decorator installer.  Also note that while not shown here, both scenes can access each other's bindings as if everything was in the same scene.

- The Validate command (`CTRL+ALT+V`) can be used to quickly verify the different multi-scene setups.  If you find that scenes are unloaded when you do this see [here](https://github.com/modesttree/UniDi/issues/168).

- Decorator scenes must be loaded before the scenes that they are decorating.

- Unity currently doesn't have a built-in way to save and restore multi-scene setups.  We use a simple editor script for this that you can find [here](https://gist.github.com/svermeulen/8927b29b2bfab4e84c950b6788b0c677) if interested.

- Finally, if you want to save yourself some time you could add a [default scene](#default-scene-parents) for the contract name that you are using above

## Sub-Containers And Facades

See [here](Documentation/SubContainers.md).

## Writing Automated Unit Tests / Integration Tests

See [here](Documentation/WritingAutomatedTests.md).

## Philosophy Of UniDi

One thing that is helpful to be aware of in terms of understanding the design of UniDi is that unlike many other frameworks it is **not opinionated**.  Many frameworks, such as ROR, ECS, ASP.NET MVC, etc. make rigid design choices for you that you have to follow.  The only assumption that UniDi makes is that you are writing object oriented code and otherwise, how you design your code is entirely up to you.

In my view, dependency injection is pretty fundamental to object oriented programming.  And without a dependency injection framework, the composition root quickly becomes a headache to maintain.  Therefore dependency injection frameworks are fairly fundamental as well.

And that's all UniDi strives to be - a dependency injection framework that targets Unity.  There are certainly quite a few features in UniDi, but they are all optional.  If you want, you can follow traditional unity development and use MonoBehaviours for every class, with the one exception that you use `[Inject]` instead of `[SerializeField]`.  Or you can abandon MonoBehaviours's completely and use the included interfaces such as ITickable and IInitializable.  It is up to you which design you want to use.

Of course, using a DI framework has some disadvantages compared to more rigid frameworks.  The main drawback is that it can be more challenging for new developers to get up and running quickly in a code base, because they need to understand the specific architecture chosen by the previous developers.  Whereas with rigid frameworks developers are given a very clear pathway to follow and so can be productive more quickly.  It is more difficult to make huge design mistakes when using a rigid framework.  However, with this rigidity also comes limitations, because whatever design decisions that are enforced by the framework might not necessarily be ideal for every single problem.

## Notes About Destruction/Dispose Order

If you add bindings for classes that implement `IDisposable`, then you can control the order that they are disposed in by setting the [execution order](#update--initialization-order).  However this is not the case for GameObjects in the scene.

Unity has a concept of "script execution order" however this value does not affect the order that OnDestroy is executed.  The root-level game objects might be destroyed in any order and this includes the SceneContext as well.

One way to make this more predictable is to place everything underneath SceneContext.   For cases where a deterministic destruction order is needed this can be very helpful, because it will at least guarantee that the bound IDisposables get disposed of first before any of the game objects in the scene.  You can also toggle the setting on SceneContext "Parent New Objects Under Scene Context" to automatically parent all dynamically instantiated objects under SceneContext as well.

Another issue that can sometimes arise in terms of destruction order is the order that the scenes are unloaded in and also the order that the DontDestroyOnLoad objects (including ProjectContext) are unloaded in.

Unfortunately, Unity does not guarantee a deterministic destruction order in this case either, and you will find that sometimes when exiting your application, the DontDestroyOnLoad objects are actually destroyed before the scenes, or you will find that a scene that was loaded first was also the first to be destroyed which is usually not what you want.

If the scene destruction order is important to you, then you might consider also changing the UniDiSetting `Ensure Deterministic Destruction Order On Application Quit` to true.  When this is set to true, this will cause all scenes to be forcefully destroyed during the OnApplicationQuit event, using a more sensible order than what unity does by default.  It will first destroy all scenes in the reverse order that they were loaded in (so that earlier loaded scenes are destroyed later) and will finish by destroying the DontDestroyOnLoad objects which include project context.

The reason this setting is not set to true by default is because it can cause crashes on Android as discussed [here](https://github.com/ssannandeji/UniDi-2019/issues/301).

## UniRx Integration

[UniRx](https://github.com/neuecc/UniRx) is a library that brings Reactive Extensions to Unity.  It can greatly simplify your code by thinking of some kinds of communication between classes as 'streams' of data.  For more details see the [UniRx docs](https://github.com/neuecc/UniRx).

UniDi integration with UniRx is disabled by default.  To enable, you must add the define `UNIDI_SIGNALS_ADD_UNIRX` to your project, which you can do by selecting Edit -> Project Settings -> Player and then adding `UNIDI_SIGNALS_ADD_UNIRX` in the "Scripting Define Symbols" section

With UniDi version 7.0.0, you'll also have to change the UniDi.asmdef file to the following:

```
{
    "name": "UniDi",
    "references": [
        "UniRx"
    ]
}
```

With `UNIDI_SIGNALS_ADD_UNIRX` enabled, you can observe UniDi signals via UniRx streams as explained in the [signals docs](Documentation/Signals.md), and you can also observe UniDi events such as Tick, LateTick, and FixedTick etc. on the `TickableManager` class.  One example usage is to ensure that certain events are only handled a maximum of once per frame:

```csharp
public class User
{
    public string Username;
}

public class UserManager
{
    readonly List<User> _users = new List<User>();
    readonly Subject<User> _userAddedStream = new Subject<User>();

    public IReadOnlyList<User> Users
    {
        get { return _users; }
    }

    public IObservableRx<User> UserAddedStream
    {
        get { return _userAddedStream; }
    }

    public void AddUser(User user)
    {
        _users.Add(user);
        _userAddedStream.OnNext(user);
    }
}

public class UserDisplayWindow : IInitializable, IDisposable
{
    readonly TickableManager _tickManager;
    readonly CompositeDisposable _disposables = new CompositeDisposable();
    readonly UserManager _userManager;

    public UserDisplayWindow(
        UserManager userManager,
        TickableManager tickManager)
    {
        _tickManager = tickManager;
        _userManager = userManager;
    }

    public void Initialize()
    {
        _userManager.UserAddedStream.Sample(_tickManager.TickStream)
            .Subscribe(x => SortView()).AddTo(_disposables);
    }

    void SortView()
    {
        // Sort the displayed user list
    }

    public void Dispose()
    {
        _disposables.Dispose();
    }
}
```

In this case we have some costly operation that we want to run every time some data changes (in this case, sorting), and all it does is affect how something is rendered (in this case, a displayed list of user names).  We could implement ITickable and then set a boolean flag every time the data changes, then perform the update inside Tick(), but this isn't really the reactive way of doing things, so we use Sample() instead.

## Auto-Mocking using Moq

See [here](Documentation/AutoMocking.md).

## Creating Unity EditorWindow's with UniDi

If you need to add your own Unity plugin, and you want to create your own EditorWindow derived class, then you might consider using UniDi to help manage this code as well.  Let's go through an example of how you might do this:

1. Right click underneath an Editor folder in your project view then select `Create -> UniDi -> Editor Window`.  Let's call it TimerWindow.
2. Open your new editor window by selecting the menu item `Window -> TimerWindow`.
3. Right now it is empty, so let's add some content to it.  Open it up and replace the contents with the following:

```csharp
public class TimerWindow : UniDiEditorWindow
{
    TimerController.State _timerState = new TimerController.State();

    [MenuItem("Window/TimerWindow")]
    public static TimerWindow GetOrCreateWindow()
    {
        var window = EditorWindow.GetWindow<TimerWindow>();
        window.titleContent = new GUIContent("TimerWindow");
        return window;
    }

    public override void InstallBindings()
    {
        Container.BindInstance(_timerState);
        Container.BindInterfacesTo<TimerController>().AsSingle();
    }
}

class TimerController : IGuiRenderable, ITickable, IInitializable
{
    readonly State _state;

    public TimerController(State state)
    {
        _state = state;
    }

    public void Initialize()
    {
        Debug.Log("TimerController initialized");
    }

    public void GuiRender()
    {
        GUI.Label(new Rect(25, 25, 200, 200), "Tick Count: " + _state.TickCount);

        if (GUI.Button(new Rect(25, 50, 200, 50), "Restart"))
        {
            _state.TickCount = 0;
        }
    }

    public void Tick()
    {
        _state.TickCount++;
    }

    [Serializable]
    public class State
    {
        public int TickCount;
    }
}
```

In the InstallBindings method for your UniDiEditorWindow, you can add IInitializable, ITickable, and IDisposable bindings just like you do within your scenes.  There is also a new interface called `IGuiRenderable` that you can use to draw content to the window by using Unity's immediate mode gui.

Note that every time your code is compiled again within Unity, your editor window is reloaded.  InstallBindings is called again and all your classes are created again from scratch.  This means that any state information you may have stored in member variables will be reset.  However, the member fields in EditorWindow derived class itself is serialized, so you can take advantage of this to have state persist across re-compiles.  In the example above, we are able to have the current tick count persist by wrapping it in a Serializable class and including this as a member inside our EditorWindow.

Something else to note is that the rate at which the ITickable.Tick method gets fired can change depending on what you have on focus.  If you run our timer window, then select another window other than Unity, you can see what I mean.  (Tick Count increments much more slowly)

## Optimization Recommendations/Notes

1. Use [memory pools](#memory-pools) with an initial size.  This should restrict all the costly instantiate operations to scene startup and allow you to avoid any performance spikes once the game starts.  Or, if you want to be really thorough, you could use a fixed size, which would trigger exceptions when the pool size limit is reached.

2. Use [reflection baking](#reflection-baking).  This is often simply a matter of enabling it and forgetting it, and can eliminate as much as 45% of the time spent running UniDi code during scene startup.

3. Use Unity's Profiler.  When Unity's profiler is open, UniDi automatically adds profiling samples for all the common UniDi interface operations including IInitializable.Initialize, ITickable.Tick, IDisposable.Dispose, etc.  in a similar way that unity does this automatically for all MonoBehaviour methods.  So, if you implement ITickable then you should see Foo.Tick in the profiler where Foo is one of your classes.

One common frustration people have when they start to profile their UniDi project is that it can be difficult to distinguish between time spent in UniDi versus time spent in their own code.  And therefore it can be tempting to blame UniDi.  This is especially the case when looking at the costs related to scene startup, since the SceneContext.Awake method appears to eat up a lot of the frame.  SceneContext.Awake is where the install is triggered, and also where the entire object graph is constructed, so contains within it a combination of UniDi code and also user code.

To help determine how much of this initial performance hit is UniDi compared to your own code, you can enable the define UNIDI_INTERNAL_PROFILING in your player settings.  After doing this, if you run the scene you should see a more detailed break-down of all the costs incurred while invoking SceneContext.Awake.  After enabling this flag and running your scene, the profiling output should appear in the console like this:

```
SceneContext.Awake detailed profiling: Total time tracked: 3104.19 ms.  Details:
  67.2% (02960x) (2086 ms) User Code
  19.4% (01243x) (0602 ms) Type Analysis - Direct Reflection
  06.1% (02928x) (0189 ms) DiContainer.Resolve
  02.3% (00003x) (0071 ms) Other
  02.3% (00259x) (0071 ms) DiContainer.Bind
  01.3% (01112x) (0041 ms) DiContainer.Instantiate
  00.7% (01032x) (0023 ms) Searching Hierarchy
  00.4% (01243x) (0011 ms) Type Analysis - Calling Baked Reflection Getter
  00.3% (01852x) (0010 ms) DiContainer.Inject
```

Or, if you enable reflection baking, then the 'Direct Reflection' costs should be eliminated and it should appear more like this:

```
SceneContext.Awake detailed profiling: Total time tracked: 2357.43 ms.  Details:
  79.1% (02964x) (1865 ms) User Code
  06.4% (02928x) (0151 ms) DiContainer.Resolve
  06.2% (01243x) (0145 ms) Type Analysis - Calling Baked Reflection Getter
  02.8% (00003x) (0067 ms) Other
  02.4% (00259x) (0057 ms) DiContainer.Bind
  01.5% (01112x) (0034 ms) DiContainer.Instantiate
  00.8% (01852x) (0020 ms) DiContainer.Inject
  00.8% (01032x) (0018 ms) Searching Hierarchy
```

As you can see, in this case 79% of the costs incurred by calling SceneContext.Awake method were related to our game code (labelled here as User Code) rather than UniDi.

Note that when not using reflection baking, the costs associated with 'Direct Reflection' above should mostly only occur at startup.  This is because after the first time these costs are incurred, the results are cached.

You can also get minor gains in speed and minor reductions in memory allocations by defining `UNIDI_STRIP_ASSERTS_IN_BUILDS` in build settings.  This will cause all asserts to be stripped out of builds.  However, note that debugging any UniDi related errors within builds will be made significantly more difficult by doing this.

For some benchmarks on UniDi versus other DI frameworks, see [here](https://github.com/svermeulen/IocPerformance) (see the charts at the bottom in particular).

## Reflection Baking

One easy way to squeeze extra performance out of UniDi is to enable a feature called Reflection Baking.  This will move some of the costs associated with analyzing the types in your codebase (aka reflection) from runtime to build time.  In one of our products at Modest Tree, turning on baking resulted in a 45% reduction in UniDi startup time (which amounted to around 424 milliseconds saved).  Results vary project to project depending on how many types are used and the target platform, but is often noticeable.

Reflection Baking will also reduce the time taken to instantiate new objects.  This is especially true on IL2CPP platforms, where instantiating via reflection is typically slower due to restrictions there.

To enable for your project, simply right click somewhere in the project tab and select Create -> UniDi -> Reflection Baking Settings. Now if you build your project again, reflection costs inside UniDi should be mostly eliminated.

By default, reflection baking will modify all the generated assemblies in your project.  These include all the assemblies that Unity generates and places in the Library/ScriptAssemblies folder, and does not include any assemblies that are placed underneath the Assets directory (however you can also apply reflection baking there too as a [separate step](#reflection-baking-external-dlls))

In many cases you will want to limit which areas of the code reflection baking is applied to.  You can do this by selecting the reflection baking settings object, unchecking the `All Generated Assemblies` flag, and then explicitly adding the assemblies you want to use to the `Include Assemblies` property.  Or you can leave the `All Generated Assemblies` flag set to true and instead limit which assemblies are changed by adding one or more regular expressions to the Namespace Patterns field, and also changing the `Exclude Assemblies` property.  For example, if all of your game code lives underneath the `ModestTree.SpaceFighter` namespace, then you could ensure that the reflection baking only applies there by adding `^ModestTree.SpaceFighter` as a namespace pattern.  Note that UniDi will automatically add a namespace pattern for itself so it is not necessary for you to do this (however, it is necessary to add the UniDi assemblies to `Include Assemblies` if you do not have `All Generated Assemblies` checked)

By default, reflection baking will only apply to builds and will not be in effect while testing inside the unity editor.  If you want to temporarily disable baking you can uncheck `Is Enabled In Builds` in the inspector.  You can also force baking to apply while inside unity editor by checking `Is Enabled in Editor`.  However note that this will slow down compile times so probably will not be worth it, but can be useful when profiling to see the effect that the baking has.  Also note that if you are using Unity 2017 LTS then reflection baking can only be used by builds due to Unity API limitations.

### Baking External DLLs

When using reflection baking as described above, by adding a reflection baking settings object, this will only apply reflection baking to the C# files that are dropped directly into your unity project.  If you are using external dlls, and want to have reflection baking applied there as well, then you can do this by adding a post-build step.  There is a command line tool that you can find in the github repo by opening the `UniDi\NonUnityBuild\UniDi.sln` file and building the "UniDi-ReflectionBakingCommandLine" project.

### Under the hood

Reflection Baking uses a library called [Cecil](https://github.com/jbevain/cecil) to do IL Weaving on the generated assemblies.  What this means is that after Unity generates the DLLs for the source files in your project, UniDi will edit those DLLs directly to embed UniDi operations directly into your classes.   Normally, UniDi has to iterate over every field, property, methods, and constructors of your classes to find what needs to be injected, and this is where the reflection costs are incurred.  However, once a class has reflection baking applied, then UniDi just needs to call a static method on your class to retrieve all the information that it needs, which can be much faster.

### Coverage Settings

There are two settings on ProjectContext related to reflection baking that can be useful to be aware of.  `Editor Reflection Baking Coverage Mode` and `Builds Reflection Baking Coverage Mode`.  These values will determine what behaviour UniDi should use when encountering types that do not have baked reflection information (Editor for when inside unity editor and Builds for when running inside generated builds).  The choices are:

1. Fallback To Direct Reflection - This will cause UniDi to incur the necessary reflection operations when baking info is not found.  This is the default.
1. No Check Assume Full Coverage - With this value set, if no reflection baking information is found for a given type, then UniDi will assume that the type does not contain any reflection information.  This can be useful in cases where there is a lot of third party code that does not have reflection baking applied, but also does not use UniDi in any way.   When coverage mode is set to (1), then this can be costly because UniDi will still analyze the third party code using reflection operations.  Note that when this is set, you will need to ensure that reflection baking is always applied everywhere that uses UniDi.
1. Fallback To Direct Reflection With Warning - With this value set, when UniDi encounters a type that does not have reflection baking applied, it will use costly reflection operations, but will also issue a warning.  This can be useful if your intention is to get full coverage with reflection baking, but you don't want to use mode (2) and cause things to completely break when certain types are missed by the baking process

## Upgrade Guide for UniDi 6

The biggest backwards-incompatible change in UniDi 6 is that the signals system was re-written from scratch and works quite differently now.  However - if you want to continue using the previous signals implementation you can get a UniDi-6-compatible version of that [here](https://github.com/svermeulen/UniDiSignalsOld). So to use that, just import UniDi 6 and make sure to uncheck the `OptionalExtras/Signals` folder, and then add the UniDiSignalsOld folder to your project from that link.

Another backwards-incompatible change in UniDi 6 is that AsSingle can no longer be used across multiple bind statements when mapping to the same instance.  In UniDi 5.x and earlier, you could do the following:

```csharp
public interface IFoo
{
}

public class Foo : IFoo
{
}

public void InstallBindings()
{
    Container.Bind<Foo>().AsSingle();
    Container.Bind<IFoo>().To<Foo>().AsSingle();
}
```

However, if you attempt this in UniDi 6, you will get runtime errors.  The UniDi 6 way of doing this is now this:

```csharp
public void InstallBindings()
{
    Container.Bind(typeof(Foo), typeof(IFoo)).To<Foo>().AsSingle();
}
```

Or, alternatively you could do it this way as well:

```csharp
public void InstallBindings()
{
    Container.Bind<Foo>().AsSingle();
    Container.Bind<IFoo>().To<Foo>().FromResolve();
}
```

The reason this was changed was because supporting the previous way of using AsSingle had large implementation costs and was unnecessary given these other ways of doing things.

Another change that may cause issues is that for every binding that is a lookup there is both a plural form and a non plural form.  This includes the following:

- FromResource / FromResources
- FromResolve / FromResolveAll
- FromComponentInNewPrefab / FromComponentsInNewPrefab
- FromComponentInNewPrefabResource / FromComponentsInNewPrefabResource
- FromComponentInHierarchy / FromComponentsInHierarchy
- FromComponentSibling / FromComponentsSibling
- FromComponentInParents / FromComponentsInParents
- FromComponentInChildren / FromComponentsInChildren

So if you were previously using one of these methods to match multiple values you will have to change to use the plural version instead.

Another change worth mentioning is that the default value for the 'includeInactive' flag passed to the FromComponent methods was changed from false to true as discussed [here](https://github.com/ssannandeji/UniDi-2019/issues/275)
There were also a few things that were renamed:

- `Factory<>` is now called `PlaceholderFactory<>` (in this case you should just get warnings about it however)
- BindFactoryContract is now called BindFactoryCustomInterface.  BindMemoryPool has a similar method called BindMemoryPoolCustomInterface
- UniDi.Lazy was renamed to UniDi.LazyInject to address a naming conflict with System.Lazy  (We'd like to use System.Lazy directly but this causes issues on IL2CPP)
- ByNewPrefab bind method was renamed to ByNewContextPrefab

## DiContainer Methods

In addition to the bind methods documented above, there are also some other methods you might want to occasionally use on DiContainer.  For example, if you are writing a custom factory, you might want to directly call one of the `DiContainer.Instantiate` methods.  Or you might have a situation where another library is creating instances of your classes (for example, a networking library) and you need to manually call DiContainer.Inject.

DiContainer is always added to itself, so you can always get it injected into any class.  However, note that injecting the DiContainer is usually a sign of bad practice, since there is almost always a better way to design your code such that you don't need to reference DiContainer directly (the exception being custom factories, but even in that case it's often better to [inject a factory into your custom factory](Documentation/Factories.md#custom-factories).  Once again, best practice with dependency injection is to only reference the DiContainer in the "composition root layer" which includes any custom factories you might have as well as the installers.  However there are exceptions to this rule.

### DiContainer.Instantiate

---

These instantiate methods might be useful for example inside a custom factory.  Note however that in most cases, you can probably get away with using a normal [Factory](#creating-objects-dynamically-using-factories) instead without needing to directly reference DiContainer.

When instantiating objects directly, you can either use DiContainer or you can use IInstantiator, which DiContainer inherits from.  IInstantiator exists because often, in custom factories, you are only interested in the instantiate operation so you don't need the Bind, Resolve, etc. methods

1. **Instantiate&lt;T&gt;** - Create the given class using the new operator and then inject it.  Note that this method should not be used for Components/MonoBehaviours.  However, it can be used for ScriptableObject derived classes (in which case UniDi will automatically call ScriptableObject.CreateInstance).

    ```csharp
    Foo foo = Container.Instantiate<Foo>();
    ```

    You can also pass extra arguments to it like this:

    ```csharp
    Foo foo = Container.Instantiate<Foo>(new object[] { "foo", 5 });
    ```

    There is also non-generic versions:

    ```csharp
    Foo foo = (Foo)Container.Instantiate(typeof(Foo));
    Foo foo = (Foo)Container.Instantiate(typeof(Foo), new object[] { "foo", 5 });
    ```

1. **InstantiatePrefab** - Instantiate the given prefab and then inject into any MonoBehaviour's that are on it.

    ```csharp
    GameObject gameObject = Container.InstantiatePrefab(MyPrefab);
    ```

    This method is equivalent to calling `var gameObject = GameObject.Instantiate(MyPrefab)` yourself and then calling `DiContainer.Inject(gameObject)`.  Note that MyPrefab above can either be a GameObject or it can be a direct reference to a component on the prefab.

    Similar to `GameObject.Instantiate`, you can also pass an initial parent transform to use:

    ```csharp
    GameObject gameObject = Container.InstantiatePrefab(MyPrefab, MyParentTransform);
    ```

1. **InstantiatePrefabResource** - Same as InstantiatePrefab except instead of passing a prefab, you pass a path within the unity Resources folder where the prefab exists.

    ```csharp
    GameObject gameObject = Container.InstantiatePrefabResource("path/to/myprefab");
    ```

    This method is simply a shortcut to calling `Container.InstantiatePrefab(Resources.Load("path/to/myprefab"));`

1. **InstantiatePrefabForComponent&lt;T&gt;** - Instantiates the given prefab, injects on the prefab, and then returns the given component which is assumed to exist somewhere in the hierarchy of the prefab.

    ```csharp
    var foo = Container.InstantiatePrefabForComponent<Foo>(FooPrefab)
    ```

    Unlike the InstantiatePrefab methods above, this method also allows passing parameters to the given component:

    ```csharp
    var foo = Container.InstantiatePrefabForComponent<Foo>(FooPrefab, new object[] { "asdf", 6.0f })
    ```

1. **InstantiatePrefabResourceForComponent&lt;T&gt;** - Same as InstantiatePrefabForComponent, except the prefab is provided as a resource path instead of as a direct reference

    ```csharp
    var foo = Container.InstantiatePrefabResourceForComponent<Foo>("path/to/fooprefab")
    var foo = Container.InstantiatePrefabResourceForComponent<Foo>("path/to/fooprefab", new object[] { "asdf", 6.0f })
    ```

1. **InstantiateComponent&lt;T&gt;** - Add the given component to a given game object.

    ```csharp
    var foo = Container.InstantiateComponent<Foo>(gameObject);
    var foo = Container.InstantiateComponent<Foo>(gameObject, new object[] { "asdf", 6.0f });
    ```

    Note that this is equivalent to calling GameObject.AddComponent yourself then immediately calling DiContainer.Inject on the new component instance.

1. **InstantiateComponentOnNewGameObject&lt;T&gt;** - Create a new empty game object then instantiate a new component of the given type on it

    ```csharp
    var foo = Container.InstantiateComponentOnNewGameObject<Foo>();
    var foo = Container.InstantiateComponentOnNewGameObject<Foo>(new object[] { "zxcv" });
    ```

    This is similar to calling `new GameObject()`, then call DiContainer.InstantiateComponent on the result.

1. **InstantiateScriptableObjectResource&lt;T&gt;** - Instantiate the given ScriptableObject type which is assumed to exist at the given resource path.  Note that if you want to create an entirely new ScriptableObject, you can just use DiContainer.Instantiate.

    ```csharp
    var foo = Container.InstantiateScriptableObjectResource<Foo>("path/to/fooscriptableobject")
    var foo = Container.InstantiateScriptableObjectResource<Foo>("path/to/fooscriptableobject", new object[] { "asdf", 6.0f })
    ```
### DiContainer.Bind

---

See [here](#binding)

### DiContainer.Resolve

---

1.  **DiContainer.Resolve** - Get instance to match the given type.  This may involve creating a new instance or it might return an existing instance, depending on how the given type was bound.

    ```csharp
    Container.Bind<Foo>().AsSingle();
    ...
    var foo = Container.Resolve<Foo>();
    ```

    An exception will be thrown if no bindings were found for the given type or if multiple bindings were found.  See TryResolve / ResolveAll for those cases.

1.  **DiContainer.ResolveId** - Same as resolve except includes an identifier

    ```csharp
    Container.Bind<Foo>().WithId("foo1").AsSingle();
    ...
    var foo = Container.ResolveId<Foo>("foo1");
    ```

1.  **DiContainer.TryResolve** - Same as DiContainer.Resolve except instead of throwing an exception when a match is not found, a null value is returned.

    ```csharp
    var foo = Container.TryResolve<Foo>();

    if (foo != null)
    {
        ...
    }
    ```

1.  **DiContainer.TryResolveId** - Same as DiContainer.TryResolve except also takes an identifier

1.  **DiContainer.ResolveAll** - Same as DiContainer.Resolve except it will return all matches instead of assuming just one.

    ```csharp
    List<Foo> foos = Container.ResolveAll<Foo>();
    ```

1.  **DiContainer.ResolveIdAll** - Same as DiContainer.ResolveAll except also takes an identifier

1.  **DiContainer.ResolveType** - Returns the type that would be retrieved/instantiated if Resolve is called with the same type/identifier.

    ```csharp
    if (Container.ResolveType<IFoo>() == typeof(Foo))
    {
        ...
    }
    ```

    This is safe to call during install phase since nothing will be instantiated by calling this.  Note also that if there are multiple matches found or zero matches then an exception will be thrown.

1.  **DiContainer.ResolveTypeAll** - Same as ResolveType except returns all matches instead of assuming a single match.

### DiContainer.Inject

1.  **DiContainer.Inject** - Inject on the given instance.

    ```csharp
    Container.Inject(foo);
    ```

    Note that you can also pass extra arguments to inject:

    ```csharp
    Container.Inject(foo, new object[] { "asdf", 6 });
    ```

    This will inject in the following order:

    1. Fields
    1. Properties
    1. Inject methods

1.  **DiContainer.InjectGameObject** - Inject into all MonoBehaviour's attached to the given game object as well as any children.

    ```csharp
    Container.InjectGameObject(gameObject);
    ```

    Note that it will inject all the components in their dependency order.  So if A is injected into B and B is injected into C, then A will be injected first, then B, then C, regardless of where in the hierarchy they are all placed

1.  **DiContainer.InjectGameObjectForComponent** - Same as InjectGameObject except it will return the given component after injection completes.

    ```csharp
    var foo = Container.InjectGameObjectForComponent<Foo>(gameObject);
    ```

    Also, unlike InjectGameObject, this method supports passing extra arguments to the given component:

    ```csharp
    var foo = Container.InjectGameObjectForComponent<Foo>(gameObject, new object[] { "asdf", 5.1f });
    ```

    Note however that it is assumed here that there is only one match for the given component.  Multiple matches (or zero matches) will generate an exception.

### DiContainer.QueueForInject

---

**DiContainer.QueueForInject** will queue the given instance for injection once the initial object graph is constructed.

Sometimes, there are instances that are not created by UniDi and which exist at startup, and which you want to be injected.  In these cases you will often add them to the container like this:

```csharp
var foo = new Foo();
...
Container.Bind<Foo>().FromInstance(foo);
```

Or, equivalently, using this shortcut:

```csharp
Container.BindInstance(foo);
```

However, using FromInstance will not cause the given instance to be injected.

One approach would be to inject on the instance immediately like this:

```csharp
Container.BindInstance(foo);
Container.Inject(foo);
```

However, this is bad practice.   You do not ever want to instantiate or inject during the install phase, because the objects that you are injecting could require bindings that have not yet been added.

Therefore the correct way to handle these cases is to use QueueForInject:

```csharp
Container.BindInstance(foo);
Container.QueueForInject(foo);
```

This way, our `foo` object will be injected at the same time the initial object graph is constructed, immediately after the install phase.

Another important advantage of using QueueForInject is that UniDi will guarantee that your instances are injected in the correct order.  In other words, if you have the following classes:

```csharp
class A
{
    [Inject]
    public void Init()
    {
        ...
    }
}

class B
{
    [Inject]
    public void Init(A a)
    {
        ...
    }
}
```

And they are added to the container this way:

```csharp
var a = new A();
var b = new B();

Container.BindInstance(a);
Container.BindInstance(b);

Container.QueueForInject(a);
Container.QueueForInject(b);
```

Then, you can assume that A will have its inject method called before B, regardless of the order that they were added to the container.  This is nice in the case where you have some initialization logic that occurs in the `[Inject]` method for B, and which requires that A has been initialized.

This is also precisely how the initial MonoBehaviour's in the scene are injected.  They are all simply added to the container with the QueueForInject method.

### DiContainer Unbind / Rebind

---

It is possible to remove or replace bindings that were added in a previous bind statement.  Note however that using methods are often a sign of bad practice.

1. **Unbind** - Remove all bindings matching the given type/id from container.

    ```csharp
    Container.Bind<IFoo>().To<Foo>();

    // This will nullify the above statement
    Container.Unbind<IFoo>();
    ```

1. **Rebind** - Override existing bindings with a new one.  This is equivalent to calling unbind with the given type and then immediately calling bind afterwards.

    ```csharp
    Container.Bind<IFoo>().To<Foo>();

    Container.Rebind<IFoo>().To<Bar>();
    ```

### Other DiContainer methods

---

1.  **DiContainer.ParentContainers** - The parent containers for the given DiContainer.  For example, for the DiContainer associated with SceneContext, this will usually be the DiContainer associated with the ProjectContext (unless you're using Scene Parenting in which case it will be another SceneContext)
1.  **DiContainer.IsValidating** - Returns true if the container is being run for validation.  This can be useful in some edge cases where special logic needs to be added during the validation step only.
1.  **DiContainer.CreateSubContainer** - Creates a new container as a child of the current container.  This might be useful for custom factories that involve creating objects with complex inter-dependencies.  For example:

    ```csharp
    var subContainer = Container.CreateSubContainer();

    subContainer.Bind<Foo>();
    subContainer.Bind<Bar>();
    subContainer.Bind<Qux>();

    var foo = subContainer.Resolve<Foo>();
    ```

    Although in most cases you should probably use the FromSubContainerResolve methods rather than doing it this way.

1.  **DiContainer.HasBinding** - Returns true if a binding that matches the given type/id has already been added.  This can be useful if you want to avoid adding a duplicate binding that may have been added in a previous installer

    ```csharp
    if (!Container.HasBinding<IFoo>())
    {
        Container.Bind<IFoo>().To<Foo>().AsSingle();
    }
    ```

1.  **DiContainer.GetDependencyContracts** - Returns a list of all the types that the given type depends on.  This might be useful, for example, if you wanted to do some static analysis of your project, or if you wanted to automatically generate a dependency diagram, etc.

## Frequently Asked Questions

### Isn't this overkill?  I mean, is using statically accessible singletons really that bad?

For small enough projects, I would agree with you that using a global singleton might be easier and less complicated.  But as your project grows in size, using global singletons will make your code unwieldy.  Good code is basically synonymous with loosely coupled code, and to write loosely coupled code you need to (A) actually be aware of the dependencies between classes and (B) code to interfaces (however I don't literally mean to use interfaces everywhere, as explained [here](#overusinginterfaces))

In terms of (A), using global singletons, it's not obvious at all what depends on what, and over time your code will become really convoluted, as everything will tend towards depending on everything.  There could always be some method somewhere deep in a call stack that does some hail mary request to some other class anywhere in your code base.  In terms of (B), you can't really code to interfaces with global singletons because you're always referring to a concrete class

With a DI framework, in terms of (A), it's a bit more work to declare the dependencies you need up-front in your constructor, but this can be a good thing too because it forces you to be aware of the dependencies between classes.

And in terms of (B), it also forces you to code to interfaces.  By declaring all your dependencies as constructor parameters, you are basically saying "in order for me to do X, I need these contracts fulfilled".  These constructor parameters might not actually be interfaces or abstract classes, but it doesn't matter - in an abstract sense, they are still contracts, which isn't the case when you are creating them within the class or using global singletons.

Then the result will be more loosely coupled code, which will make it 100x easier to refactor, maintain, test, understand, re-use, etc.

### Is there a way to integrate with the upcoming Unity ECS?

Currently there does not appear to be an official way to do custom injections into Unity ECS systems, however, there are [some workarounds](https://forum.unity.com/threads/request-for-world-addmanager.539271/#post-3558224) until Unity hopefully addresses this.

### Does this work on AOT platforms such as iOS and WebGL?

Yes.  However, there are a few things that you should be aware of.  One of the things that Unity's IL2CPP compiler does is strip out any code that is not used.  It calculates what code is used by statically analyzing the code to find usage.  This is great, except that this will sometimes strip out methods/types that we don't refer to explicitly (and instead access via reflection instead).

In some versions of Unity, or with some settings applied (eg. a higher level of code stripping), IL2CPP can sometimes strip out the constructors of classes, resulting in errors on IL2CPP platforms.  The recommended fix in these cases is to either edit `link.xml` to force your types to not be stripped (see Unity docs) or to add an `[Inject]` attribute above the constructor.  Adding this attribute signals to IL2CPP to not strip out this method.

If you do want to use a higher level of code stripping, and decide to go the route of adding `[Inject]` attributes to all constructors, then you might also want to change the `ConstructorChoiceStrategy` value inside the settings found on `ProjectContext` to `InjectAttribute`.  This can be useful because it will force you to explicitly add `[Inject]` attributes to all constructors while testing in Unity Editor, rather than having to test on IL2CPP platforms to discover these problems.  Note however that this would probably be unnecessary with 'Low' code stripping.

Sometimes, another issue that can occur is with classes that have generic arguments and which are instantiated with a "value type" generic argument (eg. int, float, enums, anything deriving from struct, etc.).  In this case, compiling on AOT platforms will sometimes strip out the constructor, so UniDi will not be able to create the class and you will get a runtime error.  For example:
```csharp
public class Foo<T1>
{
    public Foo()
    {
        Debug.Log("Successfully created Foo!");
    }
}

public class Runner2 : MonoBehaviour
{
    public void OnGUI()
    {
        if (GUI.Button(new Rect(100, 100, 500, 100), "Attempt to Create Foo"))
        {
            var container = new DiContainer();

            // This will throw exceptions on AOT platforms because the constructor for Foo<int> is stripped out of the build
            container.Instantiate<Foo<int>>();

            // This will run fine however, because string is not value type
            //container.Instantiate<Foo<string>>();
        }
    }

    static void _AotWorkaround()
    {
        // As a workaround, we can explicitly reference the constructor here to force the AOT
        // compiler to leave it in the build
        // new Foo<int>();
    }
}
```

Normally, in a case like above where a constructor is being stripped out, we can force-include it by adding the `[Inject]` attribute on the Foo constructor, however this does not work for classes with generic types that include a value type.  Therefore, the recommended workarounds here are to either explicitly reference the constructor similar to what you see in the _AotWorkaround, or avoid using value type generic arguments.  One easy way to avoid using value types is to wrap it in a reference type (for example, by using something like [this](https://gist.github.com/svermeulen/a6929e6e26f2de2cc697d24f108c5f85))

### How is performance?

See [here](#optimization-recommendationsnotes).

### <a id="faq-multiple-threads">Does UniDi support multithreading?</a>

Yes, with a few caveats:

- You need to enable the define `UNIDI_MULTITHREADING` in player settings
- Only the resolve and instantiate operations support multithreading.  The bindings that occur during the install phase must cannot be executed concurrently on multiple threads.  In other words, everything after the initial install should support multithreading.
- Circular reference errors are handled less gracefully.  Instead of an exception with an error message that details the object graph with the circular reference, a StackOverflowException might be thrown
- If you make heavy use of UniDi from multiple threads at the same time, you might also want to enable the define `UNIDI_INTERNAL_NO_POOLS` which will cause UniDi to not use memory pools for internal operations.  This will cause more memory allocations however can be much faster in some cases because it will avoid hitting locks the memory pools uses to control access to the shared data across threads

### How do I use Unity style Coroutines in normal C# classes?

With UniDi, there is less of a need to make every class a `MonoBehaviour`.  But it is often still desirable to be able to call `StartCoroutine` to add asynchronous methods.

One solution here is to use a dedicated class and just call `StartCoroutine` on that instead.  For example:

```csharp
public class AsyncProcessor : MonoBehaviour
{
    // Purposely left empty
}

public class Foo : IInitializable
{
    AsyncProcessor _asyncProcessor;

    public Foo(AsyncProcessor asyncProcessor)
    {
        _asyncProcessor = asyncProcessor;
    }

    public void Initialize()
    {
        _asyncProcessor.StartCoroutine(RunAsync());
    }

    public IEnumerator RunAsync()
    {
        Debug.Log("Foo started");
        yield return new WaitForSeconds(2.0f);
        Debug.Log("Foo finished");
    }
}

public class TestInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Bind<IInitializable>().To<Foo>().AsSingle();
        Container.Bind<AsyncProcessor>().FromNewComponentOnNewGameObject().AsSingle();
    }
}
```

Another solution to this problem which I highly recommend is [UniRx](https://github.com/neuecc/UniRx).

Yet another option is to use a coroutine library that implements similar functionality to what Unity provides.  See [here](https://github.com/svermeulen/UnityCoroutinesWithoutMonoBehaviours) for one example that we've used in the past at Modest Tree

### Are there any more sample projects to look at?

Complete examples (with source) using UniDi:

* [UniDi Hero](https://github.com/Mathijs-Bakker/UniDi-Hero) - Remake of the classic Atari game H.E.R.O.   Based on UniDi 6
* [Quick Golf](https://assetstore.unity.com/packages/templates/packs/quick-golf-67900) - Mini-golf game
* [EcsRx Roguelike 2D](https://github.com/grofit/ecsrx.roguelike2d) - An example of a Roguelike 2d game using EcsRx and UniDi
* [Push The Squares](https://assetstore.unity.com/packages/templates/packs/push-the-squares-69780) - This is the puzzle game in which you have to find the proper way to connect squares with stars of the same color. 
* [Submarine](https://github.com/shiwano/submarine) - A mobile game that is made with Unity3D, RoR, and WebSocket server written in Go.
* [Craberoid](https://github.com/Crabar/Craberoid-3.0) - Arkanoid clone

### What games/applications/libraries are using UniDi?

You can find a comprehensive list of solutions that have UniDi under the hood [here](Documentation/GamesThatUseUniDi.md).

### I keep getting errors complaining about circular reference!  How to address this?

If two classes are injected into each other and both classes use contructor injection, then obviously it is not possible for UniDi to create both of these classes.  However, what you can do instead is switch to use method injection or field/property injection instead.  Or, alternatively, you could use the [LazyInject<>](#just-in-time-resolve) construct.

## Cheat Sheet

See [here](Documentation/CheatSheet.md).

## Further Help

For general troubleshooting / support, please use the [UniDi subreddit](http://www.reddit.com/r/UniDi) or the [UniDi google group](https://groups.google.com/forum/#!forum/UniDi/).  If you have found a bug, you are also welcome to create an issue on the [github page](https://github.com/svermeulen/Extenject), or a pull request if you have a fix / extension.  Finally, you can also email me directly at sfvermeulen@gmail.com or follow me on twitter at [@steve_verm](https://twitter.com/steve_verm)

## Release Notes

See [here](Documentation/ReleaseNotes.md).

## License

    The MIT License (MIT)

    Copyright (c) 2010-2015 Modest Tree Media  http://www.modesttree.com

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

```
